// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file underlay_message.cpp
 * This source file contains the definition of the described types in the IDL
 * file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "cyber/transport/rtps/underlay_message.h"

#include <utility>

#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>
// using namespace  eprosima::fastcdr::exception;
using eprosima::fastcdr::exception::BadParamException;
using eprosima::fastcdr::exception::Exception;
using eprosima::fastcdr::exception::NotEnoughMemoryException;

#define UnderlayMessage_max_cdr_typesize 528ULL;
#define UnderlayMessage_max_key_cdr_typesize 0ULL;

namespace apollo {
namespace cyber {
namespace transport {

UnderlayMessage::UnderlayMessage() {
  // long m_timestamp
  m_timestamp = 0;
  // long m_seq
  m_seq = 0;
  // string m_data
  m_data = "";
  // string m_datatype
  m_datatype = "";
}

UnderlayMessage::~UnderlayMessage() {}

UnderlayMessage::UnderlayMessage(const UnderlayMessage& x) {
  m_timestamp = x.m_timestamp;
  m_seq = x.m_seq;
  m_data = x.m_data;
  m_datatype = x.m_datatype;
}

UnderlayMessage::UnderlayMessage(UnderlayMessage&& x) noexcept {
  m_timestamp = x.m_timestamp;
  m_seq = x.m_seq;
  m_data = std::move(x.m_data);
  m_datatype = std::move(x.m_datatype);
}

UnderlayMessage& UnderlayMessage::operator=(const UnderlayMessage& x) {
  m_timestamp = x.m_timestamp;
  m_seq = x.m_seq;
  m_data = x.m_data;
  m_datatype = x.m_datatype;

  return *this;
}

UnderlayMessage& UnderlayMessage::operator=(UnderlayMessage&& x) noexcept {
  m_timestamp = x.m_timestamp;
  m_seq = x.m_seq;
  m_data = std::move(x.m_data);
  m_datatype = std::move(x.m_datatype);

  return *this;
}

bool UnderlayMessage::operator==(const UnderlayMessage& x) const {
  return (m_timestamp == x.m_timestamp && m_seq == x.m_seq &&
          m_data == x.m_data && m_datatype == x.m_datatype);
}

bool UnderlayMessage::operator!=(const UnderlayMessage& x) const {
  return !(*this == x);
}

size_t UnderlayMessage::getMaxCdrSerializedSize(size_t current_alignment) {
  static_cast<void>(current_alignment);
  return UnderlayMessage_max_cdr_typesize;
}

size_t UnderlayMessage::getCdrSerializedSize(const UnderlayMessage& data,
                                             size_t current_alignment) {
  (void)data;
  size_t initial_alignment = current_alignment;

  current_alignment +=
      4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

  current_alignment +=
      4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

  current_alignment += 4 +
                       eprosima::fastcdr::Cdr::alignment(current_alignment, 4) +
                       data.data().size() + 1;

  current_alignment += 4 +
                       eprosima::fastcdr::Cdr::alignment(current_alignment, 4) +
                       data.datatype().size() + 1;

  return current_alignment - initial_alignment;
}

void UnderlayMessage::serialize(eprosima::fastcdr::Cdr& scdr) const {
  scdr << m_timestamp;
  scdr << m_seq;
  scdr << m_data;
  scdr << m_datatype;
}

void UnderlayMessage::deserialize(eprosima::fastcdr::Cdr& dcdr) {
  dcdr >> m_timestamp;
  dcdr >> m_seq;
  dcdr >> m_data;
  dcdr >> m_datatype;
}

/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void UnderlayMessage::timestamp(int32_t _timestamp) {
  m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
int32_t UnderlayMessage::timestamp() const { return m_timestamp; }

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
int32_t& UnderlayMessage::timestamp() { return m_timestamp; }

/*!
 * @brief This function sets a value in member seq
 * @param _seq New value for member seq
 */
void UnderlayMessage::seq(int32_t _seq) { m_seq = _seq; }

/*!
 * @brief This function returns the value of member seq
 * @return Value of member seq
 */
int32_t UnderlayMessage::seq() const { return m_seq; }

/*!
 * @brief This function returns a reference to member seq
 * @return Reference to member seq
 */
int32_t& UnderlayMessage::seq() { return m_seq; }

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void UnderlayMessage::data(const std::string& _data) { m_data = _data; }

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void UnderlayMessage::data(std::string&& _data) { m_data = std::move(_data); }

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::string& UnderlayMessage::data() const { return m_data; }

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::string& UnderlayMessage::data() { return m_data; }
/*!
 * @brief This function copies the value in member datatype
 * @param _datatype New value to be copied in member datatype
 */
void UnderlayMessage::datatype(const std::string& _datatype) {
  m_datatype = _datatype;
}

/*!
 * @brief This function moves the value in member datatype
 * @param _datatype New value to be moved in member datatype
 */
void UnderlayMessage::datatype(std::string&& _datatype) {
  m_datatype = std::move(_datatype);
}

/*!
 * @brief This function returns a constant reference to member datatype
 * @return Constant reference to member datatype
 */
const std::string& UnderlayMessage::datatype() const { return m_datatype; }

/*!
 * @brief This function returns a reference to member datatype
 * @return Reference to member datatype
 */
std::string& UnderlayMessage::datatype() { return m_datatype; }

size_t UnderlayMessage::getKeyMaxCdrSerializedSize(size_t current_alignment) {
  static_cast<void>(current_alignment);
  return UnderlayMessage_max_key_cdr_typesize;
}

bool UnderlayMessage::isKeyDefined() { return false; }

void UnderlayMessage::serializeKey(eprosima::fastcdr::Cdr& scdr) const {
  (void)scdr;
}

}  // namespace transport
}  // namespace cyber
}  // namespace apollo
